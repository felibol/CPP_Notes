Ilk bir saat kayip.

----------------

Fuction call operator overloading
---------------------------------
operator()
STL de ve template de cok yaygin kullaniliyor.

Functor class
Lambda exp []{return random_name() + random_fname();}

Sinifin primitive turlerden birine donduren operatoru varsa, primitive ture donusturup primitive turlerin operatorelerini kullanir.
operator int()const;

STL konusuna kadar operator overloading e ara veriyoruz.

Nested Types (Icsel turler)
----------------------------
class Myclass{
public:
	typedef int Word;
	enum Color{Blue. Red}
	class Nec{
		int mx;
	};
};


Name lookup


Note: Sinifin icinde stataic non static ve friend func lar tanimlanabilir

class Myclass{
public:
	func()
	{
		Word mx; // this works, can find Word
	};
	using Word = int;
};

nested type public private protected olabilir. ayni erisim kontrollerine tabi

encloser class nested type in public olmayan ogelerine erisemez. Bu erisim icin nested class encloser a friendlik verebilir.

Nested class encloser class in private bolumune erisebilir. cpp11 den sonra den once erisemiyordu.
non static member ler icin tabi ki hala bir object e ihtiyac duyacak.

Note: sizeof operatorun icerisi icin kod uretilmez.

Nested class encloser class icinde forward decl yapilabilir. encloser sinif icinde impl yapilabilir yada disinda da yapilabilir. disinda yapildiginda encloser scope u yazilmali

Nested class func encloser icinde nested class icinde tanimlanabilir yada disarda da tanimlanabilir. Yine disarda iken scope yailmali enclose::nested::func()
Nested in uye func i encloser class icinde ama nested disinda olacak sekilde tanimlanamaz.

Note: func taniminda parametre yazilan yer class scope ta ama donus degeri degil.

Encloser in private olan uye turune nested func ta return value olarak kullanmak istersek, client kodda private turu ismiyle yazzarsak scope disi olacak syntax error ama auto ile erisilebilir.

STL de nested type ornekleri;
string  sinifiin iteratorleri
vector<int>::iterator iter=ivec.begin();
auto iter = ivec.begin(); // bundan once yukardaki gibiydi

-------------------------------

pimpl(pointer implementation) idiom mulakatlarda sik soruluyor
opaque pointer
cashire cat vb isimlerde veriliyor

sinifin private bolumunu gizlemeye yonelik
neden isteyelim: 
-> okuyanin bilgi sahibi olmasini engellemek
-> baska sinif turunden uyesi varsa, incomplete type kullanmak sansi yok. ama ptr yaparsa incomplete type kullanabilir.
-> kullanilan butun type lar icin onlarin tanimlandigi headerlari include etmesi gerek
-> bu durumda compile da etkileniyor. bu basliklardan biri degisirse include edilen yerde tekrar derlenecek.
-> dependency de artmis oluyor. include edilen header in include ettigi headerlara da bagimlilik olmus oluyor.

bir baslik dosyasini include etmem gerekiyor mu?
1-> complete - incomplete type ayrimi yapilmali, incomplete type kullanilabilir ise sadece forward decl edip include etmeden devam edilebilir. static member gibi
2-> eger data memeber varsa basliktaki turden o zaman bunu gizlemek cozum oluyor.

#include "a.h"
#include "b.h"
#include "c.h"

class Myclass{
private:
A ax;
B bx;
C cx;
}

//myclass.h
class Myclass{
private:
	Myclass();
	func();
	struct Pimpl;
	Pimpl *mp;	// incomplete type ptr olarak kullanilabilir normalde raw ptr yerine std::unique_ptr<Pimpl> kullanilir
}

//myclass.cpp
#include "a.h"
#include "b.h"
#include "c.h"

struct Myclass::Pimpl{
	A ax;
	B bx;
	C cx;
}

Myclass::Myclass() : mp{new Pimple}
{

}

Myclass::func()
{
	ax.f();		// gizlenmeseydi boyle kullanilacakti
	mp->ax.f(); // artik bu sekilde de kullanilacak
}






