# Lecture Notes

## 2019/09/03 Lecture 01

## [2019/09/05 Lecture 02](online_cpp_02_2019_09_05.md)

- Initiliazation

## [2019/09/10 Lecture 03](online_cpp_03_2019_09_10.md)

- Initiliazation
- reference semantics

## [2019/09/12 Lecture 04](online_cpp_04_2019_09_12.md)

- const expression
- constexpr function
- type deduction
- auto
- decltype

## 2019/09/17 Lecture 05

- default argument
- function overloading

## 2019/09/19 Lecture 06

- function overload resolution
  - 1a- exact match
  - 1b- promotion
  - 1c- conversion
- function delete
- enum ve enum class

## 2019/09/24 Lecture 07

- extern "C" bildirimi
- Tur donusum operatorleri
- Classes

## 2019/09/26

- Deprem nedeniyle iptal edildi.

## 2019/10/01 Lecture 08

- Class member functions static, non static, const, non const
- Function Overloading in classes
- This pointer

- class scope kavramı
- sınıflar ve isim arama (name lookup)
- erişim kontrolü (access control) ve veri gizleme (data hiding)
- public öğeler
- private öğeler
- protected öğeler
- sınıfların öğeleri (class members)
- sınıfların veri öğeleri (data members)
- non-static veri öğeleri
- mutable veri öğeleri
- static veri öğeleri
- sınıfların üye işlevleri
- non-static üye işlevler
- const üye işlevler
- static üye işlevler

## 2019/10/03 Lecture 09

- sınıfların kurucu işlevleri (constructors)
- kurucu işlev ilk değer verme listesi (constructor initializer list)
- delege eden kurucu işlevler (delegating constructors)
- sınıfların sonlandırıcı işlevleri (destructors)

## 2019/10/08 Lecture 10

## 2019/10/08 Lecture 11

## 2019/10/08 Lecture 12

## 2019/10/08 Lecture 13

## 2019/10/08 Lecture 14

## 2019/10/08 Lecture 15

## [2019/10/08 Lecture 16](online_cpp_16_2019_10_29.md)

## 2019/10/08 Lecture 17

## [2019/10/08 Lecture 18](online_cpp_18_2019_11_05.md)

## [2019/10/08 Lecture 19](online_cpp_19_2019_11_07.md)

## [2019/10/08 Lecture 20](online_cpp_20_2019_11_12.md)

## [2019/10/08 Lecture 21](online_cpp_21_2019_11_14.md)

## [2019/10/08 Lecture 22](online_cpp_22_2019_11_19.md)

## [2019/10/08 Lecture 23](online_cpp_23_2019_11_21.md)

## [2019/10/08 Lecture 24](online_cpp_24_2019_11_26.md)

## [2019/10/08 Lecture 25](online_cpp_25_2019_11_28.md)

## [2019/10/08 Lecture 26](online_cpp_26_2019_12_03.md)

## [2019/10/08 Lecture 27](online_cpp_27_2019_12_05.md)

## [2019/10/08 Lecture 28](online_cpp_28_2019_12_10.md)

## [2019/10/08 Lecture 29](online_cpp_29_2019_12_12.md)

## [2019/10/08 Lecture 30](online_cpp_30_2019_12_17.md)

## [2019/10/08 Lecture 31](online_cpp_31_2019_12_19.md)

## 2019/10/08 Lecture 32

## 2019/10/08 Lecture 33

## 2019/10/08 Lecture 34

## [2020/01/07 Lecture 35](online_cpp_35_2020_01_07.md)

- Lambda Expresssion
- STL Algos
- algoritmaların lambda ifadelerini kullanması
- lambda ifadeleri
- kapanış türleri ve kapanış nesneleri (closure types and closure objects)
- lambda ifadeleri ve tür çıkarımı (lambda expressions and type deduction)
- lambda yakalama ifadeleri (lambda captures)
- lambda init capture
- capture this
- capture *this
- mutable lambdalar
- trailing return type
- genelleştirilmiş lambda ifadeleri (generalized lambda expressions)
- algoritmalarda lambda ifadelerinin kullanımı

## [2020/01/09 Lecture 36](online_cpp_36_2020_01_09.md)

- Container lar uzerinde bazi silme algoritmalarinin kullanimi
- Lambda expressions ile ilgili bazi yeni ozellikler C++17 ile gelen
- Container lara giris
- Kaplar(Containers)
- STL kapları ve veri yapıları (STL containers & data structures)

## [2020/01/14 Lecture 37](online_cpp_37_2020_01_14.md)

- Vector

## [2020/01/16 Lecture 38](online_cpp_38_2020_01_16.md)

- Vector
  - emplace funcs
  - erase funcs
  - iterator invalidation
- deque
  - comparison with vector
  - differences in interfaces with vector
  - iterator invalidation

## [2020/01/21 Lecture 39](online_cpp_39_2020_01_21.md)

## [2020/01/23 Lecture 40](online_cpp_40_2020_01_23.md)

- list
- forward_list
- Associative containers
  - set
  - multiset

## [2020/01/28 Lecture 41](online_cpp_41_2020_01_28.md)

- Associative containers
  - map
  - multimap

## 2020/01/30 Lecture 42

## [2020/02/04 Lecture 43](online_cpp_43_2020_02_04.md)

## [2020/02/06 Lecture 44](online_cpp_44_2020_02_06.md)

## Butun Egitim Icerigi

### C++ Dilinin Genel Tanıtımı

- C++ dilinin tarihçesi
- C++ dili ve programlama paradigmaları
- C++ dili standartları
- C++98 – 03
- C++11
- C++14
- C++17
- C++20
- eski C++ ve modern C++

### C Dili ve C++ İçindeki C Dili `(C in C++)`

- C dilinden C++ diline geçiş
- işlev bildirimleri ve tanımlamalarına ilişkin farklılıklar
- türlere ve tür dönüşümlerine ilişkin farklılıklar
- C’de geçerli C++’da geçersiz durumlar
- C99 ve C++

### Temel Kavramlar `(Basic Concepts)`

- tamamlanmış ve eksik türler `(complete & incomplete types)`
- tek tanımlama kuralı `(one definition rule)`
- ifadelerin değer kategorileri `(value categories)`
- tanımsız davranış `(undefined behavior)`
- derleyiciye bağlı davranışlar. `(implementation defined & implementaion specified)`
- derleyici eklentileri `(compiler extensions)`
- kapsam `(scope)` ve isim arama `(name lookup)`
- erişim kontrolü `(access control)`
- çift anlamlılık hatası `(ambiguity)`

### İlk Değer Verme `(Initialization)`

- eş biçimli ilk değer verme `(uniform initialization)`
  - daraltıcı dönüşümler `(narrowing conversions)`
  - `most vexing parse`
- doğrudan ilk değer verme `(direct intialization)`
- değerle başlatma `value initialization`
- kopyalama ile ilk değer verme `(copy initialization)`
- varsayılan ilk değer verme `(default initialization)`
- bileşiklere ilk değer verme `(aggregate initialization)`

### Tür Çıkarımı `(Type Deduction)`

- auto belirteci ile tür çıkarımı `(auto type deduction)`
- decltype belirteci ile tür çıkarımı `(decltype type deduction)`
- sonradan gelen geri dönüş türü `(trailing  return type)`
- auto geri dönüş değeri türü `(auto return type)`

### enum Sınıfları `(enum Classes)`

- geleneksel enum türleri `(conventional enum types)`
- baz tür seçimi `(underlying type)'
- tür dönüşümleri `(type conversions)`
- enum sınıfları ve kapsam `(enum classes & scope)`

### Sabit İfadeleri `(Constant Expressions)`

- const anahtar sözcüğü ve const semantiği
- const nesneler
- constexpr anahtar sözcüğü
- constexpr işlevler

### İşlevlerin Varsayılan Argüman Alması `(Default Arguments)`

### Referans Semantiği `(Reference Semantics)`

- sol taraf referansları `(L value references)`
- sağ taraf referansları `(R value references)`
- referanslar ve const semantiği `(references & const semantics)`
- referanslar ile göstericilerin `(pointer)` karşılaştırılması
- parametresi referans olan işlevler
- referans döndüren işlevler

### İşlev Yüklemesi `(Function Overloading)`

- genel kurallar
- yüklenmiş işlev çözümlenmesi `(function overload resolution)`
- const yüklemesi `(const overloading)`
- extern “C” bildirimi
- işlev yüklemesinde dikkat edilmesi gereken durumlar

### Tür Dönüştürme Operatörleri `(Type-cast Operators)`

- static_cast<> operatörü
- const_cast<> operatörü
- reinterpret_cast<> operatörü
- dynamic_cast<> operatörü `(kalıtım başlığı altında)`

### Sınıflara giriş

- sınıf kapsamı `(class scope)`
sınıflar ve isim arama `(name lookup)`
- erişim kontrolü `(access control)` ve veri gizleme `(data hiding)`
  - public öğeler `(public members)`
  - private öğeler `(private members)`
  - protected öğeler `(protected members)`
- sınıfların öğeleri `(class members)`
  - sınıfların veri öğeleri `(data members)`
    - non-static veri öğeleri
    - mutable veri öğeleri
    - static veri öğeleri
  - sınıfların üye işlevleri
    - non-static üye işlevler
    - const üye işlevler
    - static üye işlevler
  - this göstericisi ve \*this
  - sınıfların tür öğeleri `(type members)`
- sınıfların kurucu işlevleri `(constructors)`
  - kurucu işlev ilk değer verme listesi `(constructor initializer list)`
  - delege eden kurucu işlevler `(delegating constructors)`
  - explicit kurucu işlevler `(explicit constructors)`
- sınıfların sonlandırıcı işlevleri `(destructors)`
- üye işlevlerin çağrılması
- sınıflar ve const doğruluğu `(classes & const correctness)`
  - const sınıf nesneleri `(const objects)`
  - const üye fonksiyonlar `(const member fuctions)`
- geçici sınıf nesneleri `(temporary objects)`
- otomatik tür dönüşümleri `(implicit type conversions)` 
- mutable anahtar sözcüğü
- friend bildirimi `(friend declarations)` 
  - friend bildirimi ve veri gizleme
  - global işlevlere friend bildirimi
  - sınıfların üye işlevlerine friend bildirimi
  - sınıflara friend bildirimi
  - attorney client idiyomu

### Sınıfların Özel Üye İşlevleri ve Kopyalama İşlemleri `Special Member Functions & Copy Control)`

- sınıfların özel işlevleri
  - default constructor `(varsayılan kurucu işlev)`
  - destructor `(sonlandırıcı işlev)`
  - copy constructor `(kopyalayan kurucu işlev)`
  - move constructor `(taşıyan kurucu işlev)`
  - copy assignment `(kopyalayan atama işlevi)`
  - move assignment `(taşıyan atama işlevi)`
- özel işlevlerin default edilmesi
- özel işlevlerin delete edilmesi
- sınıflar ve taşıma semantiği `(move semantics)`
- `rule of zero`
- `rule of five`
- kopyala takas et idiyomu `(copy & swap idiom)`
- kopyalamanın eliminasyonu `(copy elision)`
  - zorunlu kopyalama eliminasyonu `(mandatory copy elision)`

### Operatör Yüklemesi `(Operator Overloading)`

- operatör yüklemesine ilişkin genel kurallar
- üye operatör fonksiyonları
- global operatör fonksiyonları
- aritmetik operatörlerin yüklenmesi
- karşılaştırma operatörlerinin yüklenmesi
- "++" ve "--" operatörlerinin yüklenmesi
- ok operatörü ve içerik operatörlerinin yüklenmesi
- [] operatörünün yüklenmesi
- fonksiyon çağrı operatörünün yüklenmesi
- tür dönüştürme operatör fonksiyonları `(type-cast operator functions)`
- programcının tanımladığı sabitler `(user-defined literals)`

### Dinamik Ömürlü Nesneler `(Dynamic Objects)`

- new ve delete ifadeleri `(new & delete expressions)` 
- new[] ve delete [] ifadeleri
- operator new işlevleri
- operator delete işlevleri
- operator new ve operator delete işlevlerinin yüklenmesi
- std::bad_alloc
- std::set_new_handler ve std::get_new_handler
- placement new operatörleri
- nothrow new

### Tür Eş İsimleri `(Type Alias)`

- typedef bildirimleri
- using bildirimleri

### İsim Alanları `(Namespaces)`

- isim alanlarının oluşturulması
- isim alanları ve isim arama `(namespaces & name lookup)` 
- çözünürlük operatörü ve isim alanları `(scope resoşution operator & namespaces)` 
- using bildirimi `(using declaration)`
- using namespace direktifi `(using namespace directive)` 
- argümana bağlı isim arama `(argument dependent lookup)`
- isimsiz isim alanı `(unnamed namespace)`
- içsel isim alanları `(nested namespaces)`
- inline isim alanları `(inline namespaces)`
- isim alanı eş ismi `(namespace alias)`
- işlev yüklemesi ve isim alanları `(function overloading & namespaces)` 

### Sınıflar ve Kalıtım `(Classes & Inheritance)`

- nesne yönelimli programlama ve kalıtım `(OOP & inheritance)`
- public kalıtımı `(public inheritance)`
- çalışma zamanı çok biçimliliği `(runtime polymorphism)`
  - sanal işlevler `(virtual function)`
  - saf sanal işlevler `(pure virtual function)`
  - sanal sonlandırıcı işlev `(virtual destructor)`
  - sanal kurucu işlev idiyomu `(virtual constructor idiom)`
  - override bağlamsal anahtar sözcüğü
  - nesne dilimlenmesi `(object slicing)`
  - sanal olmayan arayüz idiyomu `(non-virtual interface idiom)`
- final bağlamsal anahtar sözcüğü `(final contextual keyword)` 
  - final sınıflar `(final classes)`
  - `final override`
- çoklu kalıtım `multiple inheritance)`
  - çoklu kalıtımda kapsam ve isim arama`(multiple inheritance & name lookup)` 
  - çoklu kalıtımda sınıfın özel işlevleri
  - elmas formasyonu `(diamond formation)`
  - sanal kalıtım `(virtual inheritance)`
  - çoklu kalıtım ve kalıtımla alınan kurucu işlevler
  - çoklu kalıtımda kopyalama ve taşıma işlemleri
- private kalıtımı `(private inheritance)`
- protected kalıtımı `(protected inheritance)`
- sınıf içi using bildirimi 
- kalıtımla alınan kurucu işlev `(inherited constructor)`

### Olağan Dışı Durumların İşlenmesi `(Exception Handling)`

- exception güvenliği `(exception safety)`
- hata nesnelerinin gönderilmesi `(throwing exception objects)`
  - throw deyimi `(throw statement)`
  - rethrow deyimi `(rethrow statement)`
- try blokları
- catch blokları
  - catch all
- yakalanamayan hata nesnesi `(uncaught exception)`
- std::terminate
- std::set_terminate
- hata nesnesinin yeniden gönderilmesi `(rethrow statement)`
- yığının geri sarımı `(stack unwinding)`
- kurucu işlevlerden exception gönderimi
- sonlandırıcı işlevler ve hata gönderimi
- exception handling ve kalıtım `(eception handling & inheritance)`
- exception handling ve dinamik ömürlü sınıf nesneleri `(eception handling & dynamic objects)`
- exception  güvenliği için akıllı göstericilerin kullanımı `(eception handling & smart pointers)`
- işlev try blokları `(function try block)`
- noexcept belirleyicisi `(noexcept specifier)`
- beklenmeyen hata nesnesi `(unexpected excetion)`
- std::unexpected_exception
- std::exception sınıfı ve hiyerarşisi
  - std::exception sınıfı ve what sanal fonksiyonu
  - std::logic_error
    - std::invalid_argument
    - std::domain_error
    - std::length_error
    - std::out_of_range
    - std::future_error
  - std::runtime_error
    - std::range_error
    - std::overflow_error
    - std::underflow_error
  - std::system_error
  - std::regex_error
  - std::bad_alloc
  - std::bad_typeid
  - std::bad_cast
  - std::bad_exception
  - std::bad_weak_ptr
  - std::bad_function_call
- kendi hata sınıflarımızı oluşturmak
- exception garantileri `(eception guarantees)`
  - `basic exception guarantee`
  - `strong exception gurantee`
  - `no throw gurantee`
- std::current_exception
- std::exception_ptr
- std::rethrow_exception

### Çalışma Zamanında Tür Belirlenmesi `(RTTI)`

- dynamic_cast operatörü
- typeid operatörü
- std::typeinfo sınıfı
- std::bad_typeid

### std::string sınıfı

- genel kavramlar
- string::size_type
- string::npos
- arama işlevleri
- set işlemleri
- erişim işlemleri
- karşılaştırma işlevleri
- sayısal dönüşüm işlevleri
- small string optimization

### Bileşik Nesneler `(composition)`

- öğe olan nesneler ve özel işlevler, kopyalama kontrolü.
- öğe olan nesneler ve erişim kontrolü
- bileşik nesnelerin kullanıldığı temalar

### İçsel türler `(Type Members)`

- sınıf içinde yapılan eş isim bildirimleri
- içsel sınıflar `(nested classes)`
- `pimpl` idiyomu

### Şablonlar `(Templates)`

- şablon tür parametreleri `(template type parameters)`
- şablon sabit parametreleri `(template non-type parameters)`
- şablon şablon parametreleri `(template template parameters)`
- şablon argümanları `(template arguments)`
- şablonlardan kod üretimi `(template instantiation)`
- fonksiyon şablonları `(function templates)`
  - fonksiyon şablonlarında tür çıkarımı `(function template argument deduction)`
  - fonksiyon şablonlarının yüklenmesi `(function template overloading)`
- sınıf şablonları `(class templates)`
- kurucu işlev ile tür çıkarımı `(CTAD)`
- üye şablonlar `(member templates)`
- şablonların özelleştirilmesi `(template specialization)`
  - tam özelleştirme `(explicit/full specialization)`
  - kısmi özelleştirme `(partial specialization)`
- `sfinae`
- değişken sayıda parametreli şablonlar `(variadic templates)`
- mükemmel gönderim `(perfect forwarding)`
- katlama ifadeleri `(fold expressions)`
- `if constexpr`
- değişken şablonları `(variable templates)`
- eş isim şablonları `(alias templates)`

### İteratörler `(iterators)`

- aralık kavramı `(ranges)`
- iteratörlerin kategorileri `(iterator categories)`
  - input iterator
  - output iterator
  - forward iterator
  - bidirectional iterator
  - random access iterator
- kapların begin ve end işlevleri
- global begin ve end işlevleri
- iterator işlevleri
  - std::next
  - std::prev
  - std::iter_swap
  - std::advance
  - std::distance
- iterator uyumlandırıcıları `(iterator adaptors)`
  - akım iteratörleri `(stream iterators)`
    - istream_iterator
    - ostream_iterator
    - istreambuf_iterator
    - ostreambuf_iterator
  - reverse iterators
  - move iterators
  - insert iterators
    - back_insert_iterator
    - front_insert_iterator
    - insert_iterator
- iterator traits

### Kaplar`(Containers)`

- STL kapları ve veri yapıları `(STL containers & data structures)`
- sıralı kaplar `(sequence containers)`
  - std::vector
  - std::deque
  - std::string
  - std::array
  - std::list
  - std::forward_list
- ilişkisel kaplar `(associative containers)`
  - std::set
  - std::multiset
  - std::map
  - std::multimap
- sırasız ilişkisel kaplar `(unordered containers)`
  - std::unordered_set
  - std::unordered_multiset
  - std::unordered_map
  - std::unordered_multimap
- kapların tür öğeleri `(type members of containers)`
- kapların emplace işlevleri

### Kap Uyumlandırıcıları `(Container Adaptors)`

- stack
- queue
- priority_queue

### Algoritmalar `(Algorithms)`

- algoritmaların temel özellikleri ve genel ilkeler
- salt okuyan algoritmalar `non-modifying algorithms)`
- kap öğelerini değiştiren algoritmalar `(modifying algorithms)`
- kap öğelerini konumlandıran algoritmalar `(mutating algorithms)`
- sıralama ile ilgili algoritmalar `(sorting algorithms)`
- sıralanmış aralıklar üzerinde koşturulan algoritmalar `(sorted range algorithms)`
- nümerik algoritmalar `(numeric algorithms)`
- algoritmaların lambda ifadelerini kullanması

### Lambda İfadeleri `(Lambda Expressions)`

- kapanış türleri ve kapanış nesneleri `(closure types and closure objects)`
- lambda ifadeleri ve tür çıkarımı `(lambda expressions and type deduction)`
- lambda yakalama ifadeleri `(lambda captures)`
- `lambda init capture`
- capture this 
- capture `*this`
- mutable lambdalar
- trailing return type
- genelleştirilmiş lambda ifadeleri `(generalized lambda expressions)`
- algoritmalarda lambda ifadelerinin kullanımı

### Akıllı Gösterici Sınıfları `(Standard Smart Pointer Classes)`

- unique_ptr sınıfı
- std::make_unique işlev şablonu
- std::default_delete ve custom deleters
- tipik hatalar
- shared_ptr sınıfı
- referans sayımı `(reference counting)`
- std::make_shared
- weak_ptr sınıfı

### Standart Giriş Çıkış Kütüphanesi `(iostream Library)`

- giriş çıkış akımlarına ilişkin standart sınıflar `(standard stream classes)`
- global akım nesneleri 
- formatlı giriş çıkış işlemleri `(formatted input output)`
- << ve >> operatörlerinin yüklenmesi `(inserter & extractors)`
- formatlama ve formatlama işlemleri `(formatting)`
- manipülatörler `(manipulators)`
- akımın durumu `(condition states)`
- string akımları `(stringstreams)`
- dosya işlemleri `(file operations)`
- formatsız giriş ve çıkış işlemleri `(unformatted input output)`
- bellek üstünde yapılan giriş çıkış işlemleri

### Bazı önemli STL Öğelerinin Tanıtımı

- std::pair
- std::tuple
- std::initializer_list
- std::bitset
- std::regex
- type_traits kütüphanesi
- std::allocator
- std::ratio
- std::chrono
- standart random kütüphanesi
- std::string_view sınıfı
- std::optional sınıfı
- std::variant sınıfı
- std::any sınıfı
- std::byte
- std::invoke

### Tamamlayıcı Araçlar ve Sentaks Öğeleri

- static_assert 
- decltype(auto)
- declval
- üye fonksiyon göstericileri `(member function pointers)`
- ham string sabitleri `(raw string literals)`
- ikilik sayı sisteminde yazılan sabitler `(binary literals)`
- basamak ayırıcısı `(digit seperator)`
- ilk değer vermeli if deyimi `(if with initializer)`
- ilk değer vermeli switch  deyimi `(if with initializer)`
- alignas belirteci `(alignas specifier)`
- alignof operatörü `(alignof operator)`
- yapısal bağlama `(structural binding) (C++17)`
- attribute’lar

### Concurrency

- memory model
- thread’ler ve thread yönetimi
- std::this_thread isim alanı
- data race kavramı ve data_race’den kaçınma
- standart mutex sınıfları ve mutex işlemleri
- lock_guard ve unique_lock sınıfları
- std::condition_variable sınıfı
- std::future ve std::promise sınıfları
- std::async işlevi
- atomik türler `(atomic types)`
- görev tabanlı `(task based)` programlama
- std::packaged_task sınıfı
- paralel STL algoritmaları
